package org.cloud.storage.cli.exceptions.handlers;

<<<<<<< Updated upstream
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.Mockito;

public class RunnableCommandExceptionsHandlerTest {
	private static final String EXCEPTION_MESSAGE = "exceptionMessage";

=======
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.Spy;
import org.mockito.junit.MockitoJUnitRunner;
import org.slf4j.Logger;

@RunWith(MockitoJUnitRunner.class)
public class RunnableCommandExceptionsHandlerTest {
	private static final String EXCEPTION_MESSAGE = "exceptionMessage";

	@Spy
>>>>>>> Stashed changes
	private RunnableCommandExceptionsHandler runnableCommandExceptionsHandler;

	@Mock
	private Exception exception;

<<<<<<< Updated upstream
	@Test
	public void test() {
		runnableCommandExceptionsHandler = Mockito.spy(new RunnableCommandExceptionsHandler());

		Mockito.doReturn(EXCEPTION_MESSAGE).when(exception).getMessage();
		runnableCommandExceptionsHandler.handle(exception);
		Mockito.verify(runnableCommandExceptionsHandler).logErrorMessage(EXCEPTION_MESSAGE);
=======
	@Mock
	private Logger logger;

	@Test
	public void test() {
		when(exception.getMessage()).thenReturn(EXCEPTION_MESSAGE);
		doReturn(logger).when(runnableCommandExceptionsHandler).getLogger();

		runnableCommandExceptionsHandler.handle(exception);

		verify(runnableCommandExceptionsHandler).logErrorMessage(EXCEPTION_MESSAGE);
		verify(logger).error(EXCEPTION_MESSAGE);
>>>>>>> Stashed changes
	}
}
